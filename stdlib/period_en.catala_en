# Periods of time

> Module Period_en
> Using Period_internal
> Using Date_en as Date

## Definitions and operations

A period is a starting date and an end date.

```catala-metadata
declaration structure Period:
  data begin content date
  # The end date is included in the period
  data end content date

## Returns a period ranging over the given month of the given year.
declaration of_month_and_year
  content Period
  depends on pmonth content Date.Month,
    pyear content integer
  equals
    let pbegin equals
      Date.of_year_month_day of (pyear, (Date.month_to_integer of pmonth), 1)
    in
    Period {
      -- begin: pbegin
      -- end: Date.last_day_of_month of pbegin
    }

## Returns a period ranging over the given year.
declaration of_year
  content Period
  depends on pyear content integer
  equals
    Period {
      -- begin: Date.of_year_month_day of (pyear, 1, 1)
      -- end: Date.of_year_month_day of (pyear, 12, 31)
    }

## Ensures that the period is coherent (it begins before its end).
declaration valid
  content boolean
  depends on p content Period
  equals
    if p.end < p.begin then false
    else true

## Duration of a given period, in days.
declaration duration
  content duration
  depends on p content Period
  equals 1 day + p.end - p.begin

## Two periods are adjacent if the second one starts when the first stops.
declaration are_adjacent
  content boolean
  depends on p1 content Period,
    p2 content Period
  equals
    p1.end = p2.begin - 1 day

## Returns the period that encompasses both `p1` and `p2`.
declaration join
  content Period
  depends on p1 content Period,
    p2 content Period
  equals
    Period {
      -- begin: Date.min of p1.begin, p2.begin
      -- end: Date.max of p1.end, p2.end
    }

## Returns the period corresponding to the days that are both in `p1` and `p2`.
declaration intersection
  content optional of Period
  depends on p1 content Period,
    p2 content Period
  equals
    let intersection equals
      Period {
        -- begin: Date.max of p1.begin, p2.begin
        -- end: Date.min of p1.end, p2.end
      }
    in
    if valid of intersection then Present content intersection
    else Absent

## Returns `true` if the periods have an overlap of at least one day.
declaration overlap
  content boolean
  depends on p1 content Period,
    p2 content Period
  equals
    match (intersection of p1, p2) with pattern
    -- Present content p : true
    -- Absent : false

## Returns `true` if the period `p1` fully covers the period `p2`.
declaration cover
  content boolean
  depends on p1 content Period,
    p2 content Period
  equals
    p1.begin <= p2.begin and p2.end <= p1.end

## Returns `true` if the given date `d` is contained in the given period `p`.
declaration is_contained
  content boolean
  depends on p content Period,
    d content date
  equals
    p.begin <= d and d <= p.end

## Returns `true` if the given date occurs *strictly* before the period.
declaration is_before
  content boolean
  depends on p content Period,
    d content date
  equals d < p.begin

## Returns `true` if the given date occurs *strictly* after the period.
declaration is_after
  content boolean
  depends on p content Period,
    d content date
  equals d > p.end

## Finds the first period in the given list `l` that contains the date `d`.
declaration find_period
  content optional of Period
  depends on l content list of Period,
    d content date
  equals
    combine all p among l
      in found initially Absent
      with
        match found with pattern
        -- Present : found
        -- Absent : if is_contained of p, d then Present content p else Absent
```

## Operations on associated lists indexed by periods

```catala-metadata
## Sorts the given periods by starting day.
## **Edge-case**: if two periods start on the same day, their order in the list
## is preserved
declaration sort_by_date
  content list of (Period, anything of type t)
  depends on l content list of (Period, anything of type t)
  equals
    let tuple_associated_list equals to_tuple_associated_list of l in
    let sorted_tuple_associated_list equals
      Period_internal.sort of tuple_associated_list
    in
    of_tuple_associated_list of sorted_tuple_associated_list
```

## Splitting periods

```catala-metadata
## Splits the given period, returning one period per calendar month. The first
## and last elements may be non-whole months.
## **Edge-case**: if the given period is empty (begin >= end), an empty list
## is returned
declaration split_by_month
  content list of Period
  depends on p content Period
  equals of_tuple_list of Period_internal.split_by_month of to_tuple of p

## Splits the given period, returning one period per year, split on the first
## of the given month. The first and last elements returned may be non-whole
## years.
## **Edge-case**: if the given period is empty (begin >= end), an empty list
## is returned
declaration split_by_year
  content list of Period
  depends on starting_month content Date.Month,
    p content Period
  equals
    of_tuple_list of
      Period_internal.split_by_year of
        (Date.month_to_integer of starting_month),
        to_tuple of p
```

## Internal functions

```catala
declaration to_tuple
  content (date, date)
  depends on p content Period
  equals (p.begin, p.end)

declaration to_tuple_associated_list
  content list of ((date, date), anything of type t)
  depends on l content list of (Period, anything of type t)
  equals map each p among l to ((to_tuple of p.1), p.2)

declaration to_tuple_list
  content list of (date, date)
  depends on l content list of Period
  equals map each p among l to to_tuple of p

declaration of_tuple
  content Period
  depends on begin content date,
    end content date
  equals Period { -- begin: begin -- end: end }

declaration of_tuple_associated_list
  content list of (Period, anything of type t)
  depends on l content list of ((date, date), anything of type t)
  equals map each tpl among l to ((of_tuple of tpl.1), tpl.2)

declaration of_tuple_list
  content list of Period
  depends on l content list of (date, date)
  equals map each tpl among l to of_tuple of tpl
```
