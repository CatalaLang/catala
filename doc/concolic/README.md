# Concolic Testing for Catala

This document explains the concolic execution plugin for Catala, which can be used to *automatically generate high-coverage tests* for Catala programs.

## Testing the [tutorial](/examples/tutorial_en/tutorial_en.catala_en)

Concolic testing can be used to generate tests for the [Catala English-language tutorial](https://catala-lang.org/en/examples/tutorial), which contains two implementations of a simple income tax computation: [one with conflicts](https://catala-lang.org/en/examples/tutorial#The%20Catala%20language%20tutorial-Testing%20Catala%20programs-Testing%20NewIncomeTaxComputation) and [another one that fixes the conflict](https://catala-lang.org/en/examples/tutorial#The%20Catala%20language%20tutorial-Defining%20exceptions%20to%20rules-Fixing%20the%20computation).

### Instrument the Catala program using the `Concolic` plugin

```
catala Concolic examples/tutorial_en/tutorial_en.catala_en --disable_warnings
```

This command will generate an instrumented Python program `examples/tutorial_en/tutorial_en.py`. The Python program is similar to that generated by the `catala Python` command, but instead uses specially wrapped values for primitives and an additional [runtime](/runtimes/python/catala/src/catala/concolic.py) that helps the program carry both *concrete* values and corresponding *symbolic* expressions (hence the word *concolic*) for data such as money, dates, durations, etc. The symbolic expressions can be evaluated using the [Z3 solver](https://github.com/Z3Prover/z3). The runtime also provides an external API called `concolic_run` which can be used to launch systematic test-input generation.

### Run concolic testing (and find a conflict)

```python
from catala.concolic import *
from examples.tutorial_en.tutorial_en import *

concolic_run(
    # The entry point to execute with concolically generated inputs (returns the computed income tax)
    lambda input: new_income_tax_computation(NewIncomeTaxComputationIn(Individual(input.income, input.children))).income_tax,
    # A specification for input vars (in this case, we have two inputs)
    vars = [
        ConcolicVar('income', type='Money', initial=230_000_00),
        ConcolicVar('children', type='Integer', initial=0)
    ], constraints = [
        # We only care about non-negative incomes
        lambda input: input.income >= 0
    ], preferences = [
        # Prefer incomes rounding to $1000.00 are nice
        lambda input: input.income % 1000_00 == 0,
        # Prefer incomes of at least $1,000.00
        lambda input: input.income >= 1_000_00,
    ], logging=ConcolicLogLevel.INFO, currency_locale='en_US')
```

And voila! You should get three test cases, covering various code paths through the tutorial, one of which reveals the [conflict](https://catala-lang.org/en/examples/tutorial#examples/tutorial_en/tutorial_en.catala_en-382)! If the income is less than $10,000, then it is not clear whether Article 5 or Article 6 applies.

```
Running with inputs: income=$230,000.00, children=0
... Output = $72,000.00

Running with inputs: income=$1,000.00, children=0
*** ConflictError encountered in in file examples/tutorial_en/tutorial_en.catala_en, from 342:10 to 342:20!
****** Offending inputs are: income=$1,000.00, children=0

Running with inputs: income=$11,000.00, children=0
... Output = $2,200.00
Concolic execution complete! 3 paths explored.
```

### Run concolic testing (on the fixed version)

We can run concolic testing on the driver for the [fixed version](https://catala-lang.org/en/examples/tutorial#The%20Catala%20language%20tutorial-Defining%20exceptions%20to%20rules-Fixing%20the%20computation), which should not find conflicts.

```python
from catala.concolic import *
from examples.tutorial_en.tutorial_en import *

concolic_run(
    # The entry point to execute with concolically generated inputs (returns the computed income tax)
    lambda input: new_income_tax_computation_fixed(
        NewIncomeTaxComputationFixedIn(Individual(input.income, input.children), lambda _: None)).income_tax,
    # A specification for input vars (in this case, we have two inputs)
    vars = [
        ConcolicVar('income', type='Money', initial=230_000_00),
        ConcolicVar('children', type='Integer', initial=0)
    ], constraints = [
        # We only care about non-negative incomes
        lambda input: input.income >= 0
    ], preferences = [
        # Prefer incomes rounding to $1000.00 are nice
        lambda input: input.income % 1000_00 == 0,
        # Prefer incomes of more than $10,000.00
        lambda input: input.income > 10_000_00,
    ], logging=ConcolicLogLevel.INFO, currency_locale='en_US')
```

As expected, we get no conflicts, but we have also automatically generated three nice looking test cases for our tutorial:

```
Running with inputs: income=$230,000.00, children=0
... Output = $72,000.00

Running with inputs: income=$11,000.00, children=0
... Output = $2,200.00

Running with inputs: income=$9,000.00, children=6
... Output = $0.00

Running with inputs: income=$11,000.00, children=7
... Output = $0.00
Concolic execution complete! 4 paths explored.
```


## Larger example: Systematically testing [Section 121 of the US Tax Code](/examples/us_tax_code/section_121.catala_en)

First, we need to make sure that we have an appropriate entry point; that is, a scope that takes a set of inputs that the concolic engine supports and produces one or more clearly defined outputs. In particular, the concolic testing engine currently only supports primitive values for inputs; lists, structures, and enums are not supported. Here is a sample entry point that is basically a generalization of one of the existing unit tests:


```catala
declaration scope FuzzSection121SinglePerson:
  scope121a scope Section121SinglePerson
  input sale_date content date
  input gain content money
  input ownership_begin content date
  input ownership_end content date
  input usage_begin content date
  input usage_end content date
  output requirements_met condition
  output exclusion content money


scope FuzzSection121SinglePerson:
  definition scope121a.date_of_sale_or_exchange equals sale_date
  definition scope121a.gain_from_sale_or_exchange_of_property equals gain
  definition scope121a.property_ownage equals [Period {
    -- begin: ownership_begin
    -- end: ownership_end
  }]
  definition scope121a.property_usage_as_principal_residence equals [Period {
    -- begin: usage_begin
    -- end: usage_end
  }]
  definition scope121a.other_section_121a_sale equals NoOtherSaleWhereSection121aApplied
  definition requirements_met equals scope121a.requirements_met
  definition exclusion equals scope121a.income_excluded_from_gross_income
```

Now, perform concolic instrumentation and run the engine as before.

```
catala Concolic examples/us_tax_code/tests/test_section_121.catala_en --disable_warnings
```

```python
from datetime import date
from catala.concolic import *
from examples.us_tax_code.tests.test_section_121 import *

concolic_run(
    # The entry point to execute with concolically generated inputs
    #   (returns whether the criteria were met and the exclusion amount)
    lambda input: fuzz_section121_single_person(FuzzSection121SinglePersonIn(input.sale_date, input.gain,
        input.ownership_begin, input.ownership_end, input.usage_begin, input.usage_end)),
    # A specification for input vars
    [
        ConcolicVar('sale_date',       type='Date', initial=date(2021, 1, 1)),
        ConcolicVar('gain',            type='Money', initial=350_000_00),
        ConcolicVar('ownership_begin', type='Date', initial=date(2017, 1, 1)),
        ConcolicVar('ownership_end',   type='Date', initial=date(2021, 1, 1)),
        ConcolicVar('usage_begin',     type='Date', initial=date(2017, 1, 1)),
        ConcolicVar('usage_end',       type='Date', initial=date(2021, 1, 1)),
    ],
    constraints = [
        # These invariants must be true for the test case to make sense
        lambda input: input.gain > 0,
        lambda input: input.sale_date == input.ownership_end,
        lambda input: input.ownership_end > input.ownership_begin,
        lambda input: input.usage_end > input.usage_begin,
    ],
    preferences = [
        # We prefer test cases where usage period is within ownership period (this is not strictly needed)
        lambda input: input.usage_begin >= input.ownership_begin,
        lambda input: input.usage_end <= input.ownership_end,
        # We prefer the gain to be in the hundreds of thousands, and be a multiple of $1000
        lambda input: input.gain >= 100_000_00,
        lambda input: input.gain % 1000_00 == 0
    ],
    logging=ConcolicLogLevel.INFO, currency_locale='en_US')
```

The concolic engine should generate test inputs that cover allpp possible paths through the logic of Section 121.

```
Running with inputs: sale_date=2021-01-01, gain=$350,000.00, ownership_begin=2017-01-01, ownership_end=2021-01-01, usage_begin=2017-01-01, usage_end=2021-01-01
... Output = FuzzSection121SinglePerson(requirements_met=True,exclusion=$250,000.00)

Running with inputs: sale_date=2001-03-01, gain=$100,000.00, ownership_begin=1996-03-01, ownership_end=2001-03-01, usage_begin=1996-03-01, usage_end=2001-03-01
... Output = FuzzSection121SinglePerson(requirements_met=True,exclusion=$100,000.00)

Running with inputs: sale_date=2004-02-29, gain=$100,000.00, ownership_begin=2004-02-28, ownership_end=2004-02-29, usage_begin=2005-03-01, usage_end=2007-03-01
... Output = FuzzSection121SinglePerson(requirements_met=False,exclusion=$0.00)

Running with inputs: sale_date=2027-07-17, gain=$100,000.00, ownership_begin=2000-02-28, ownership_end=2027-07-17, usage_begin=2023-03-01, usage_end=2027-07-17
... Output = FuzzSection121SinglePerson(requirements_met=True,exclusion=$100,000.00)

Running with inputs: sale_date=2010-03-01, gain=$250,000.00, ownership_begin=1992-03-01, ownership_end=2010-03-01, usage_begin=2008-02-28, usage_end=2010-02-27
... Output = FuzzSection121SinglePerson(requirements_met=True,exclusion=$250,000.00)

Running with inputs: sale_date=2000-03-02, gain=$100,000.00, ownership_begin=2000-03-01, ownership_end=2000-03-02, usage_begin=2000-03-01, usage_end=2000-03-02
... Output = FuzzSection121SinglePerson(requirements_met=False,exclusion=$0.00)

Running with inputs: sale_date=2008-03-01, gain=$100,000.00, ownership_begin=2004-03-01, ownership_end=2008-03-01, usage_begin=2008-02-29, usage_end=2008-03-01
... Output = FuzzSection121SinglePerson(requirements_met=False,exclusion=$0.00)

Running with inputs: sale_date=2009-02-27, gain=$100,000.00, ownership_begin=1976-03-01, ownership_end=2009-02-27, usage_begin=2007-03-01, usage_end=2009-02-27
... Output = FuzzSection121SinglePerson(requirements_met=False,exclusion=$0.00)

Running with inputs: sale_date=2027-07-17, gain=$100,000.00, ownership_begin=1999-03-01, ownership_end=2027-07-17, usage_begin=1999-03-01, usage_end=2027-07-17
... Output = FuzzSection121SinglePerson(requirements_met=True,exclusion=$100,000.00)

Running with inputs: sale_date=2015-03-01, gain=$250,000.00, ownership_begin=2008-02-29, ownership_end=2015-03-01, usage_begin=2008-02-29, usage_end=2012-02-29
... Output = FuzzSection121SinglePerson(requirements_met=True,exclusion=$250,000.00)

Running with inputs: sale_date=2001-02-28, gain=$100,000.00, ownership_begin=1996-02-29, ownership_end=2001-02-28, usage_begin=1992-02-29, usage_end=1998-02-28
... Output = FuzzSection121SinglePerson(requirements_met=True,exclusion=$100,000.00)

Running with inputs: sale_date=2005-02-28, gain=$250,000.00, ownership_begin=2003-03-01, ownership_end=2005-02-28, usage_begin=1974-03-04, usage_end=2005-02-28
... Output = FuzzSection121SinglePerson(requirements_met=True,exclusion=$250,000.00)

Running with inputs: sale_date=2000-02-29, gain=$100,000.00, ownership_begin=1999-03-01, ownership_end=2000-02-29, usage_begin=1995-02-28, usage_end=2000-02-29
... Output = FuzzSection121SinglePerson(requirements_met=False,exclusion=$0.00)

Running with inputs: sale_date=2003-03-02, gain=$100,000.00, ownership_begin=1998-03-01, ownership_end=2003-03-02, usage_begin=1998-03-01, usage_end=2000-02-29
... Output = FuzzSection121SinglePerson(requirements_met=False,exclusion=$0.00)

Running with inputs: sale_date=2006-03-03, gain=$100,000.00, ownership_begin=2004-02-29, ownership_end=2006-03-03, usage_begin=1997-02-28, usage_end=2003-03-01
... Output = FuzzSection121SinglePerson(requirements_met=False,exclusion=$0.00)

Running with inputs: sale_date=2012-03-02, gain=$100,000.00, ownership_begin=2012-03-01, ownership_end=2012-03-02, usage_begin=2004-02-29, usage_end=2007-03-03
... Output = FuzzSection121SinglePerson(requirements_met=False,exclusion=$0.00)

Running with inputs: sale_date=2009-03-01, gain=$100,000.00, ownership_begin=2000-02-29, ownership_end=2009-03-01, usage_begin=2000-02-29, usage_end=2004-03-01
... Output = FuzzSection121SinglePerson(requirements_met=False,exclusion=$0.00)

Running with inputs: sale_date=2005-03-01, gain=$100,000.00, ownership_begin=2000-03-01, ownership_end=2005-03-01, usage_begin=2000-02-29, usage_end=2000-03-01
... Output = FuzzSection121SinglePerson(requirements_met=False,exclusion=$0.00)

Running with inputs: sale_date=2013-02-28, gain=$100,000.00, ownership_begin=2013-02-27, ownership_end=2013-02-28, usage_begin=2000-02-29, usage_end=2008-02-28
... Output = FuzzSection121SinglePerson(requirements_met=False,exclusion=$0.00)
Concolic execution complete! 19 paths explored.
```

## See also

* The [concolic_run API](API.md)
