
# Article

```catala
declaration scope S:
   input x content list of integer
   output y content integer

scope S:
  definition y equals
    content of potential_max among x such that potential_max is minimum or if list empty then -1
```



```catala-test-inline
$ catala Typecheck --check-invariants
┌─[RESULT]─
│ All invariant checks passed
└─
┌─[RESULT]─
│ Typechecking successful!
└─
```

```catala-test-inline
$ catala Lcalc -s S -O --closure-conversion
let scope S (S_in: S_in {x_in: list of integer}): S {y: integer} =
  let get x : list of integer = S_in.x_in in
  let set y : integer =
    (reduce
       (closure_y2, to_closure_env ())
       (-1, -1)
       map (closure_y1, to_closure_env ()) x).0
  in
  return { S y = y; }
```

The next test of closure conversion should give the same results, it checks that
`-O` is correctly implied by `--closure-conversion`
The detection of closures that should not be converted because they are arguments
to reduce or other special operators relies on pattern matching the special
operator and its EAbs argument. However without exceptions on, because the
lcalc translation pass is not optimized and produces more options than needed,
the closures that are arguments to special operators are let-bound with an
option. This let-binding is reduced by partial evaluation, which is why the test
with optimizations on passes.

```catala-test-inline
$ catala Lcalc -s S --closure-conversion
let scope S (S_in: S_in {x_in: list of integer}): S {y: integer} =
  let get x : list of integer = S_in.x_in in
  let set y : integer =
    match
      (match
         (handle_exceptions
            [
              match (handle_exceptions []) with
              | ENone →
                if true then
                  ESome
                    (let weights : list of (integer, integer) =
                       map (let y2 :
                                (closure_env, integer) → (integer, integer)
                                =
                              closure_y2
                            in
                            (y2, to_closure_env ()))
                         x
                     in
                     reduce
                       let y1 :
                           (closure_env, (integer, integer),
                             (integer, integer)) → (integer, integer) =
                         closure_y1
                       in
                       (y1, to_closure_env ())
                       let potential_max : integer = -1 in
                       (potential_max,
                         let potential_max1 : integer = potential_max in
                         potential_max1)
                       weights).0
                else ENone ()
              | ESome x → ESome x
            ])
       with
       | ENone → if false then ENone () else ENone ()
       | ESome x → ESome x)
    with
    | ENone → error NoValue
    | ESome arg → arg
  in
  return { S y = y; }
```
