## Article

```catala
declaration scope A:
    context output x content integer
    output o content integer

scope A:
    definition x equals 0
    definition o equals 10
    definition o under condition x>0 consequence equals 20

declaration scope B:
    a scope A
    output o content integer

declaration scope C:
    a scope A
    output o content integer

scope B:
    definition o equals a.o

scope C:
    definition a.x equals 1
    definition o equals a.o
```

By default, `A.x` is 0:

```catala-test-inline
$ catala Interpret -s A
[RESULT] Computation successful! Results:
[RESULT] o = 10
[RESULT] x = 0
```

So simply getting `A.o` raises no error:

```catala-test-inline
$ catala Interpret -s B
[RESULT] Computation successful! Results:
[RESULT] o = 10
```

But changing the value of `A.x` from another scope results in a conflict:

```catala-test-inline
$ catala Interpret -s C
[ERROR]
There is a conflict between multiple valid consequences for assigning the same variable.

This consequence has a valid justification:
┌─⯈ tests/test_concolic/bad/context.catala_en:10.25-10.27:
└──┐
10 │     definition o equals 10
   │                         ‾‾
   └─ Article

This consequence has a valid justification:
┌─⯈ tests/test_concolic/bad/context.catala_en:11.57-11.59:
└──┐
11 │     definition o under condition x>0 consequence equals 20
   │                                                         ‾‾
   └─ Article
#return code 123#
```

However, this conflict is not caught by the concolic interpreter for now, but there is a warning:

```catala-test-inline
$ catala Concolic -s A
[WARNING] An input of the scope is a context variable or a function. In that case, the concolic exploration may be INCOMPLETE, and therefore miss errors.
[RESULT] 
[RESULT] Evaluating with inputs:
[RESULT] . x_in = <function>
[RESULT] Output of scope after evaluation:
[RESULT] . o = 10
[RESULT] . x = 0
[RESULT] 
[RESULT] Concolic interpreter done
[RESULT] Computation successful!
```

Conclusion: we should give (thunked) values to context variables. However, maybe we should make sure that the default is also executed?

```catala-test-inline
$ catala DCalc -s A
let scope A
  (A_in: A_in {x_in: unit → ⟨integer⟩})
  : A {x: integer; o: integer}
  =
  let get x : unit → ⟨integer⟩ = A_in.x_in in
  let set x : integer =
    error_empty
      ⟨ x () | true ⊢ ⟨error_empty ⟨ ⟨true ⊢ ⟨0⟩⟩ | false ⊢ ∅ ⟩⟩ ⟩
  in
  let set o : integer =
    error_empty ⟨ ⟨true ⊢ ⟨10⟩⟩, ⟨x > 0 ⊢ ⟨20⟩⟩ | false ⊢ ∅ ⟩
  in
  return { A x = x; o = o; }
```

```catala-test-inline
$ catala DCalc -s B
let scope B (B_in: B_in): B {o: integer} =
  let sub_set a.x : unit → ⟨integer⟩ = λ (_: unit) → ∅ in
  let call result : A {x: integer; o: integer} = A { A_in x_in = a.x; } in
  let sub_get a.x : integer = result.x in
  let sub_get a.o : integer = result.o in
  let set o : integer = error_empty ⟨ ⟨true ⊢ ⟨a.o⟩⟩ | false ⊢ ∅ ⟩ in
  return { B o = o; }
```

```catala-test-inline
$ catala DCalc -s C
let scope C (C_in: C_in): C {o: integer} =
  let sub_set a.x : unit → ⟨integer⟩ =
    λ (_: unit) →
    ⟨ ⟨true ⊢ ⟨1⟩⟩ | false ⊢ ∅ ⟩
  in
  let call result : A {x: integer; o: integer} = A { A_in x_in = a.x; } in
  let sub_get a.x : integer = result.x in
  let sub_get a.o : integer = result.o in
  let set o : integer = error_empty ⟨ ⟨true ⊢ ⟨a.o⟩⟩ | false ⊢ ∅ ⟩ in
  return { C o = o; }
```

