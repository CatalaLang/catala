## Article

```catala
declaration enumeration EnumA:
-- A1 content integer
-- A2 content boolean

declaration enumeration EnumB:
-- B1 content EnumA
-- B2

declaration scope A:
  input x content integer
  output o content EnumB

scope A:
    definition o equals B1 content (A1 content 10)
    exception definition o under condition x = 0 consequence equals B1 content (A2 content true)
    exception definition o under condition x = 1 consequence equals B2
```

```catala-test-inline
$ catala DCalc -s A
let scope A
  (A_in: A_in {x_in: integer})
  : A {o: EnumB[B1: EnumA[A1: integer | A2: bool] | B2: unit]}
  =
  let get x : integer = A_in.x_in in
  let set o : EnumB[B1: EnumA[A1: integer | A2: bool] | B2: unit] =
    error_empty
      ⟨ ⟨ ⟨x = 0 ⊢ ⟨B1 (A2 true)⟩⟩, ⟨x = 1 ⊢ ⟨B2 ()⟩⟩ | false ⊢ ∅ ⟩
      | true ⊢ ⟨ ⟨true ⊢ ⟨B1 (A1 10)⟩⟩ | false ⊢ ∅ ⟩ ⟩
  in
  return { A o = o; }
```

```catala-test-inline
$ catala Concolic -s A
[RESULT] 
[RESULT] Evaluating with inputs:
[RESULT] . x_in = 42
[RESULT] Output of scope after evaluation:
[RESULT] . o = B1 A1 10
[RESULT] 
[RESULT] Evaluating with inputs:
[RESULT] . x_in = 0
[RESULT] Output of scope after evaluation:
[RESULT] . o = B1 A2 true
[RESULT] 
[RESULT] Evaluating with inputs:
[RESULT] . x_in = 1
[RESULT] Output of scope after evaluation:
[RESULT] . o = B2 ()
[RESULT] 
[RESULT] Concolic interpreter done
[RESULT] Computation successful!
```

