## Article

```catala
declaration scope A:
  input x content money
  input y content money
  output o1 condition
  output o2 condition

scope A:
  rule o1 under condition x = (money of -1.001)
  consequence fulfilled
  rule o2 under condition y = (money of -1.006)
  consequence fulfilled
```

`money of -1.001` and `money of -1.006` are rounded to `-1.01` by Z3 and by
OCaml. This is rounding (truncating) towards 0.
The default Z3 "real to int" coercion would give `-1.00` in both cases, so this
test checks our custom function to round towards 0.

```catala-test-inline
$ catala DCalc -s A
let scope A (A_in: A_in {x_in: money; y_in: money}): A {o1: bool; o2: bool} =
  let get x : money = A_in.x_in in
  let get y : money = A_in.y_in in
  let set o1 : bool =
    error_empty
      ⟨ ⟨ ⟨x = to_mon -1.001 ⊢ ⟨true⟩⟩ | false ⊢ ∅ ⟩
      | true ⊢ ⟨ ⟨true ⊢ ⟨false⟩⟩ | false ⊢ ∅ ⟩ ⟩
  in
  let set o2 : bool =
    error_empty
      ⟨ ⟨ ⟨y = to_mon -1.006 ⊢ ⟨true⟩⟩ | false ⊢ ∅ ⟩
      | true ⊢ ⟨ ⟨true ⊢ ⟨false⟩⟩ | false ⊢ ∅ ⟩ ⟩
  in
  return { A o1 = o1; o2 = o2; }
```

```catala-test-inline
$ catala Concolic -s A
[RESULT] 
[RESULT] Evaluating with inputs:
[RESULT] . x_in = ¤42.00
[RESULT] . y_in = ¤42.00
[RESULT] Output of scope after evaluation:
[RESULT] . o1 = false
[RESULT] . o2 = false
[RESULT] 
[RESULT] Evaluating with inputs:
[RESULT] . x_in = ¤-0.99
[RESULT] . y_in = ¤-1.00
[RESULT] Output of scope after evaluation:
[RESULT] . o1 = false
[RESULT] . o2 = true
[RESULT] 
[RESULT] Evaluating with inputs:
[RESULT] . x_in = ¤-1.00
[RESULT] . y_in = ¤42.00
[RESULT] Output of scope after evaluation:
[RESULT] . o1 = true
[RESULT] . o2 = false
[RESULT] 
[RESULT] Evaluating with inputs:
[RESULT] . x_in = ¤-1.00
[RESULT] . y_in = ¤-1.00
[RESULT] Output of scope after evaluation:
[RESULT] . o1 = true
[RESULT] . o2 = true
[RESULT] 
[RESULT] Concolic interpreter done
[RESULT] Computation successful!
```

