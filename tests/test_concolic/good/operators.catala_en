## Article

```catala
declaration scope A:
  input x content integer
  input y content integer
  input z content integer
  input t content integer
  output o content integer

scope A:
  definition o under condition not ((x*y+z < -t) and (x > y)) or ((z <= t) xor (x >= z))
  consequence equals 0
```

```catala-test-inline
$ catala DCalc -s A
let scope A
  (A_in: A_in {x_in: integer; y_in: integer; z_in: integer; t_in: integer})
  : A {o: integer}
  =
  let get x : integer = A_in.x_in in
  let get y : integer = A_in.y_in in
  let get z : integer = A_in.z_in in
  let get t : integer = A_in.t_in in
  let set o : integer =
    error_empty ⟨(~ (x * y + z < - t && x > y)) || (z <= t xor x >= z) ⊢ 0⟩
  in
  return { A o = o; }
```

```catala-test-inline
$ catala Concolic -s A
[RESULT]
Constraints: (let ((a!1 (not (<= (* (- 1) t_in) (+ (* x_in y_in) z_in)))))
(let ((a!2 (not (and a!1 (not (<= x_in y_in))))))
  (or a!2 (not (= (<= z_in t_in) (>= x_in z_in)))))),
[RESULT] Computation successful! Results:
[RESULT] o = 0
```

