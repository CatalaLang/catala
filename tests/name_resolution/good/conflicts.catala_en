This test attemts to stress the renaming engine, and trigger naming conflicts in
the backends.


```catala
declaration structure Assert_in:
  data assert content integer

declaration structure Assert__1:
  data assert content integer

declaration assert content integer depends on assert__1 content integer
  equals assert__1

declaration closure_assert content (Assert_in, Assert__1)
  equals (Assert_in { -- assert: 99 }, Assert__1 { -- assert: 199 })

#[test] declaration scope Assert:
  output assert condition

scope Assert:
  definition assert equals
  let assert equals map each x among [0] to (x+1) in false
```

```catala-test-inline
$ catala dcalc
let Assert : Assert_in → Assert =
  λ (Assert_in: Assert_in) →
  let assert : bool =
    error_empty
      ⟨ ⟨ ⟨true
           ⊢ ⟨let assert : list of integer =
                map (λ (x: integer) → x + 1) [0]
              in
              false⟩⟩
        | false ⊢ ∅ ⟩
      | true ⊢ ⟨ ⟨true ⊢ ⟨false⟩⟩ | false ⊢ ∅ ⟩ ⟩
  in
  { Assert assert = assert; }
in
let assert : integer → integer = λ (assert__1: integer) → assert__1 in
let closure_assert : (Assert_in, Assert__1) =
  ({ Assert_in assert = 99; }, { Assert__1 assert = 199; })
in
Assert
```


With `--closure-conversion`, a new toplevel definition `closure_assert` is
hoisted from scope `Assert`. However, a declaration by this name already exists,
and it should not be renamed because of the internal code, since it is part of
the exported idents when compiling this as a module:

(it's ok to rename toplevel definition, but the renaming should be fully
determined by the interface of the module: it cannot depend on the fact that the
code hoists a closure or not)

```catala-test-inline
$ catala lcalc --closure-conversion
type Eoption =
  | ENone of unit
  | ESome of any

type Assert_in = { assert: integer; }

type Assert__1 = { assert: integer; }

#[test]
type Assert_in__1 = {  }

#[test]
type Assert__2 = { assert: bool; }

let topval closure_assert : (closure_env, integer) → integer =
  λ (env: closure_env) (x: integer) →
  let env__1 : () = from_closure_env env in
  
  ((x + 1))

#[test]
let scope assert
  (assert_in: #[test] Assert_in__1)
  : #[test] Assert__2 {assert: bool}
  =
  let set assert : bool =
    match
      (match
         (ESome
            (let assert__1 : list of integer =
               map (let assert__2 : (closure_env, integer) → integer =
                      closure_assert
                    in
                    (assert__2, to_closure_env ()))
                 [0]
             in
             false, <conflicts:23.3-59>))
       with
       | ENone → ESome (false, <conflicts:19.10-16>)
       | ESome x → ESome x)
    with
    | ENone → error NoValue
    | ESome arg → arg.0
  in
  return { Assert__2 assert = assert; }

let topval assert__1 : integer → integer =
  λ (assert__1: integer) →
  assert__1

let topval closure_assert__1 :
  (Assert_in {assert: integer}, Assert__1 {assert: integer}) =
  ({ Assert_in assert = 99; }, { Assert__1 assert = 199; })

```


```catala-test-inline
$ catala ocaml --closure-conversion
(** This file has been generated by the Catala compiler, do not edit! *)

open Runtime_ocaml.Runtime

[@@@ocaml.warning "-4-26-27-32-41-42"]


module Assert_in = struct
  type t = {assert__1: integer}
end

module Assert__1 = struct
  type t = {assert__1: integer}
end

module Assert__2 = struct
  type t = {assert__1: bool}
end

module Assert_in__1 = struct
  type t = unit
end


(* Toplevel def closure_assert *)
let closure_assert : Obj.t -> integer -> integer =
  fun (env: Obj.t) (x: integer) -> (let _ : unit = (o_fromclosureenv env)
    in
    ((o_add_int_int x (integer_of_string "1"))))

(* Scope Assert *)
let assert__1 : Assert_in__1.t -> Assert__2.t = fun _ ->
  let assert__1: bool =
    match
      (match
         (Eoption.ESome
            ((let _ : integer array =
                (o_map
                   (let assert__2 : Obj.t -> integer -> integer =
                      closure_assert in
                   (assert__2, (o_toclosureenv ())))
                   ([|(integer_of_string "0")|])) in
              false),
              ({filename="tests/name_resolution/good/conflicts.catala_en";
                start_line=23; start_column=3; end_line=23; end_column=59;
                law_headings=[]})))
       with
       | Eoption.ENone _ ->
           (Eoption.ESome
              (false,
                ({filename="tests/name_resolution/good/conflicts.catala_en";
                  start_line=19; start_column=10; end_line=19; end_column=16;
                  law_headings=[]})))
       | Eoption.ESome x -> (Eoption.ESome x))
    with
    | Eoption.ENone _ -> (raise
        (Runtime_ocaml.Runtime.Error (NoValue, [{filename="tests/name_resolution/good/conflicts.catala_en";
                                                 start_line=19; start_column=10;
                                                 end_line=19; end_column=16;
                                                 law_headings=[]}])))
    | Eoption.ESome arg -> (let x, _ = arg in x) in
  {Assert__2.assert__1 = assert__1}

(* Toplevel def assert *)
let _ : integer -> integer =
  fun (assert__2: integer) -> assert__2

(* Toplevel def closure_assert *)
let _ : (Assert_in.t * Assert__1.t) =
  (({Assert_in.assert__1 = (integer_of_string "99")}),
    ({Assert__1.assert__1 = (integer_of_string "199")}))


let test_scopes = [
  "Assert";
]

let commands =
  List.map (fun c ->
      if List.mem c test_scopes then c else (
        print_endline "Specify scopes from the following list (or no argument \
                       for running them all):";
        List.iter (fun n -> print_endline ("  - " ^ n)) test_scopes;
        exit 1
      ))
    (List.tl (Array.to_list Sys.argv))

let commands = if commands = [] then test_scopes else commands

let () = if List.mem "Assert" commands then (
  let _ = assert__1 (()) in
  print_endline "\x1b[32m[RESULT]\x1b[m Scope Assert executed successfully."
)
```

```catala-test-inline
$ catala test-scope Assert
┌─[RESULT]─
│ assert = false
└─
```
