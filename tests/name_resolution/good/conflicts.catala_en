This test attemts to stress the renaming engine, and trigger naming conflicts in
the backends.


```catala
declaration structure Assert_in:
  data assert content integer

declaration structure Assert1:
  data assert content integer

declaration assert content integer depends on assert1 content integer
  equals assert1

declaration closure_assert content (Assert_in, Assert1)
  equals (Assert_in { -- assert: 99 }, Assert1 { -- assert: 199 })

declaration scope Assert:
  output assert condition

scope Assert:
  definition assert equals
  let assert equals (x+1) for x among [0] in false
```

```catala-test-inline
$ catala dcalc
let Assert : Assert_in → Assert =
  λ (Assert_in: Assert_in) →
  let assert : bool =
    error_empty
      ⟨ ⟨ ⟨true
           ⊢ ⟨let assert : list of integer =
                map (λ (x: integer) → x + 1) [0]
              in
              false⟩⟩
        | false ⊢ ∅ ⟩
      | true ⊢ ⟨ ⟨true ⊢ ⟨false⟩⟩ | false ⊢ ∅ ⟩ ⟩
  in
  { Assert assert = assert; }
in
let assert : integer → integer = λ (assert1: integer) → assert1 in
let closure_assert : (Assert_in, Assert1) =
  ({ Assert_in assert = 99; }, { Assert1 assert = 199; })
in
Assert
```


With `--closure-conversion`, a new toplevel definition `closure_assert` is
hoisted from scope `Assert`. However, a declaration by this name already exists,
and it should not be renamed because of the internal code, since it is part of
the exported idents when compiling this as a module:

(it's ok to rename toplevel definition, but the renaming should be fully
determined by the interface of the module: it cannot depend on the fact that the
code hoists a closure or not)

```catala-test-inline
$ catala lcalc --closure-conversion
type Eoption = | ENone of unit | ESome of any

type Assert_in = { assert: integer; }
type Assert1 = { assert: integer; }
type Assert_in1 = {  }
type Assert2 = { assert: bool; }

let topval closure_assert : (closure_env, integer) → integer =
  λ (env: closure_env) (x: integer) →
  let env1 : () = from_closure_env env in
  
  ((x + 1))

let scope Assert (assert_in: Assert_in1): Assert2 {assert: bool} =
  let set assert : bool =
    match
      (match
         (ESome
            (let assert : list of integer =
               map (let assert : (closure_env, integer) → integer =
                      closure_assert
                    in
                    (assert, to_closure_env ()))
                 [0]
             in
             false))
       with
       | ENone → ESome false
       | ESome x → ESome x)
    with
    | ENone → error NoValue
    | ESome arg → arg
  in
  return { Assert2 assert = assert; }

let topval assert : integer → integer =
  λ (assert1: integer) →
  assert1

let topval closure_assert1 :
  (Assert_in {assert: integer}, Assert1 {assert: integer}) =
  ({ Assert_in assert = 99; }, { Assert1 assert = 199; })

```


```catala-test-inline
$ catala ocaml --closure-conversion
(** This file has been generated by the Catala compiler, do not edit! *)

open Runtime_ocaml.Runtime

[@@@ocaml.warning "-4-26-27-32-41-42"]


module Assert_in = struct
  type t = {assert1: integer}
end

module Assert1 = struct
  type t = {assert1: integer}
end

module Assert2 = struct
  type t = {assert1: bool}
end

module Assert_in1 = struct
  type t = unit
end


let closure_assert : Obj.t -> integer -> integer =
  fun (env: Obj.t) (x: integer) -> (let _ : unit = (o_fromclosureenv env)
    in
    ((o_add_int_int x (integer_of_string "1"))))

let assert1 (_: Assert_in1.t) : Assert2.t =
  let assert1: bool =
    match
      (match
         (Eoption.ESome
            (let _ : integer array =
               (o_map
                  (let assert1 : Obj.t -> integer -> integer = closure_assert
                  in
                  (assert1, (o_toclosureenv ())))
                  ([|(integer_of_string "0")|])) in
            false))
       with
       | Eoption.ENone _ -> (Eoption.ESome false)
       | Eoption.ESome x -> (Eoption.ESome x))
    with
    | Eoption.ENone _ -> (raise
        (Runtime_ocaml.Runtime.Error (NoValue, [{filename="tests/name_resolution/good/conflicts.catala_en";
                                                 start_line=19; start_column=10;
                                                 end_line=19; end_column=16;
                                                 law_headings=[]}])))
    | Eoption.ESome arg -> arg in
  {Assert2.assert1 = assert1}

let assert2 : integer -> integer =
  fun (assert2: integer) -> assert2

let closure_assert1 : (Assert_in.t * Assert1.t) =
  (({Assert_in.assert1 = (integer_of_string "99")}),
    ({Assert1.assert1 = (integer_of_string "199")}))


let entry_scopes = [
  "Assert";
]

let commands =
  List.map (fun c ->
      if List.mem c entry_scopes then c else (
        print_endline "Specify scopes from the following list (or no argument for running them all):";
        List.iter (fun n -> print_endline ("  - " ^ n)) entry_scopes;
        exit 1
      ))
    (List.tl (Array.to_list Sys.argv))

let commands = if commands = [] then entry_scopes else commands

let () = if List.mem "Assert" commands then (
  ignore (assert1 ());
  print_endline "Scope Assert executed successfully."
)
```

```catala-test-inline
$ catala test-scope Assert
┌─[RESULT]─
│ assert = false
└─
```
