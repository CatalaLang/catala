This test attemts to stress the renaming engine, and trigger naming conflicts in
the backends.


```catala
declaration structure Assert_in:
  data assert content integer

declaration structure Assert__1:
  data assert content integer

declaration assert content integer depends on assert__1 content integer
  equals assert__1

declaration closure_assert content (Assert_in, Assert__1)
  equals (Assert_in { -- assert: 99 }, Assert__1 { -- assert: 199 })

#[test] declaration scope Assert:
  output assert condition

scope Assert:
  definition assert equals
  let assert equals map each x among [0] to (x+1) in false
```

```catala-test-cli
$ catala dcalc

type Assert_in = { assert: integer; }

type Assert__1 = { assert: integer; }

#[test]
type Assert_in = {  }

#[test]
type Assert = { assert: bool; }

#[test]
let scope Assert (Assert_in: Assert_in): Assert =
  let set assert : bool =
    error_empty
      ⟨ ⟨ ⟨true
           ⊢ ⟨let assert : list of integer =
                map (λ (x: integer) → x + 1) [0]
              in
              false⟩⟩
        | false ⊢ ∅ ⟩
      | true ⊢ ⟨ ⟨true ⊢ ⟨false⟩⟩ | false ⊢ ∅ ⟩ ⟩
  in
  return { Assert assert = assert; }

let topval assert : integer → integer =
  λ (assert__1: integer) →
  assert__1

let topval closure_assert : (Assert_in, Assert__1) =
  ({ Assert_in assert = 99; }, { Assert__1 assert = 199; })

```


With `--closure-conversion`, a new toplevel definition `closure_assert` is
hoisted from scope `Assert`. However, a declaration by this name already exists,
and it should not be renamed because of the internal code, since it is part of
the exported idents when compiling this as a module:

(it's ok to rename toplevel definition, but the renaming should be fully
determined by the interface of the module: it cannot depend on the fact that the
code hoists a closure or not)

```catala-test-cli
$ catala lcalc --closure-conversion

#[test]
type Assert_in = {  }

#[test]
type Assert = { assert: bool; }

type Assert_in__1 = { assert: integer; }

type Assert__1 = { assert: integer; }

let topval closure_assert : (closure_env, integer) → integer =
  λ (env: closure_env) (x: integer) →
  let env__1 : () = from_closure_env env in
  
  ((x + 1))

#[test]
let scope assert (assert_in: Assert_in): Assert =
  let set assert__1 : bool =
    match
      (match
         (Present
            (let assert__2 : list of integer =
               map (let assert__3 : (closure_env, integer) → integer =
                      closure_assert
                    in
                    (assert__3, to_closure_env ()))
                 [0]
             in
             false, <conflicts:23.3-59>))
       with
       | Absent → Present (false, <conflicts:19.10-16>)
       | Present x → Present x)
    with
    | Absent → error NoValue
    | Present arg → arg.0
  in
  return { Assert assert = assert__1; }

let topval assert__1 : integer → integer =
  λ (assert__1: integer) →
  assert__1

let topval closure_assert__1 : (Assert_in__1, Assert__1) =
  ({ Assert_in__1 assert = 99; }, { Assert__1 assert = 199; })

```


```catala-test-cli
$ catala ocaml --closure-conversion
(** This file has been generated by the Catala compiler, do not edit! *)

open Runtime

[@@@ocaml.warning "-4-26-27-32-41-42"]


let () =
  match Runtime.check_module "Stdlib1" "CMX|XXXXXXXX|XXXXXXXX|XXXXXXXX" with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module Stdlib1, it may need recompiling"
module Stdlib1 = Stdlib1

module Assert_in__1 = struct
  type t = {assert__1: integer}
end

module Assert__1 = struct
  type t = {assert__1: integer}
end

module Assert = struct
  type t = {assert__1: bool}
end

module Assert_in = struct
  type t = unit
end


(* Toplevel def closure_assert *)
let closure_assert : Obj.t -> integer -> integer =
  fun (env: Obj.t) (x: integer) -> (let _ : unit = (o_fromclosureenv env) in
    ((o_add_int_int x (integer_of_string "1"))))

(* Scope Assert *)
let assert__1 : Assert_in.t -> Assert.t = fun _ ->
  let assert__2: bool =
    match
      (match
         (Optional.Present
            ((let _ : integer array =
                (o_map
                   (let assert__3 : Obj.t -> integer -> integer =
                      closure_assert in (assert__3, (o_toclosureenv ())))
                   ([|(integer_of_string "0")|])) in false),
              ({filename="tests/name_resolution/good/conflicts.catala_en";
                start_line=23; start_column=3; end_line=23; end_column=59;
                law_headings=[]})))
       with
       | Optional.Absent _ ->
           (Optional.Present
              (false,
                ({filename="tests/name_resolution/good/conflicts.catala_en";
                  start_line=19; start_column=10; end_line=19; end_column=16;
                  law_headings=[]})))
       | Optional.Present x -> (Optional.Present x))
    with
    | Optional.Absent _ -> (raise
        (Runtime.Error (NoValue, [{filename="tests/name_resolution/good/conflicts.catala_en";
                                   start_line=19; start_column=10;
                                   end_line=19; end_column=16;
                                   law_headings=[]}])))
    | Optional.Present arg -> (let x, _ = arg in x) in
  {Assert.assert__1 = assert__2}

(* Toplevel def assert *)
let _ : integer -> integer =
  fun (assert__2: integer) -> assert__2

(* Toplevel def closure_assert *)
let _ : (Assert_in__1.t * Assert__1.t) =
  (({Assert_in__1.assert__1 = (integer_of_string "99")}),
    ({Assert__1.assert__1 = (integer_of_string "199")}))
```

```catala-test-cli
$ catala test-scope Assert
┌─[RESULT]─ Assert ─
│ assert = false
└─
```
