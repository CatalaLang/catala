This test attemts to stress the renaming engine, and trigger naming conflicts in
the backends.


```catala
declaration structure Assert_in:
  data assert content integer

declaration structure Assert__1:
  data assert content integer

declaration assert content integer depends on assert__1 content integer
  equals assert__1

declaration closure_assert content (Assert_in, Assert__1)
  equals (Assert_in { -- assert: 99 }, Assert__1 { -- assert: 199 })

#[test] declaration scope Assert:
  output assert condition

scope Assert:
  definition assert equals
  let assert equals map each x among [0] to (x+1) in false
```

```catala-test-cli
$ catala dcalc

type Assert_in = { assert: integer; }

type Assert__1 = { assert: integer; }

#[test]
type Assert_in = {  }

#[test]
type Assert = { assert: bool; }

#[test]
let scope Assert (Assert_in: Assert_in): Assert =
  let set assert : bool =
    error_empty
      ⟨ ⟨ ⟨true
           ⊢ ⟨let assert : list of integer =
                map (λ (x: integer) → x + 1) [0]
              in
              false⟩⟩
        | false ⊢ ∅ ⟩
      | true ⊢ ⟨ ⟨true ⊢ ⟨false⟩⟩ | false ⊢ ∅ ⟩ ⟩
  in
  return { Assert assert = assert; }

let topval assert : integer → integer =
  λ (assert__1: integer) →
  assert__1

let topval closure_assert : (Assert_in, Assert__1) =
  ({ Assert_in assert = 99; }, { Assert__1 assert = 199; })

```


With `--closure-conversion`, a new toplevel definition `closure_assert` is
hoisted from scope `Assert`. However, a declaration by this name already exists,
and it should not be renamed because of the internal code, since it is part of
the exported idents when compiling this as a module:

(it's ok to rename toplevel definition, but the renaming should be fully
determined by the interface of the module: it cannot depend on the fact that the
code hoists a closure or not)

```catala-test-cli
$ catala lcalc --closure-conversion

#[test]
type Assert_in = {  }

#[test]
type Assert = { assert: bool; }

type Assert_in__1 = { assert: integer; }

type Assert__1 = { assert: integer; }

let topval closure_assert : (closure_env, integer) → integer =
  λ (env: closure_env) (x: integer) →
  let env__1 : () = from_closure_env env in
  
  ((x + 1))

#[test]
let scope assert (assert_in: Assert_in): Assert =
  let set assert__1 : bool =
    match
      (match
         (Present
            (let assert__2 : list of integer =
               map (let assert__3 : (closure_env, integer) → integer =
                      closure_assert
                    in
                    (assert__3, to_closure_env ()))
                 [0]
             in
             false, <conflicts:23.3-59>))
       with
       | Absent → Present (false, <conflicts:19.10-16>)
       | Present x → Present x)
    with
    | Absent → error NoValue
    | Present arg → arg.0
  in
  return { Assert assert = assert__1; }

let topval assert__1 : integer → integer =
  λ (assert__1: integer) →
  assert__1

let topval closure_assert__1 : (Assert_in__1, Assert__1) =
  ({ Assert_in__1 assert = 99; }, { Assert__1 assert = 199; })

```


```catala-test-cli
$ catala ocaml --closure-conversion
(** This file has been generated by the Catala compiler, do not edit! *)

[@@@ocaml.warning "-4-26-27-32-33-34-37-41-42-69"]

open Catala_runtime


let () =
  match Catala_runtime.check_module "Stdlib_en" "CMX|XXXXXXXX|XXXXXXXX|XXXXXXXX"
    with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module Stdlib_en, it may need recompiling"
module Stdlib_en = Stdlib_en
let () =
  match Catala_runtime.check_module "Date_en" "CMX|XXXXXXXX|XXXXXXXX|XXXXXXXX"
    with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module Date_en, it may need recompiling"
module Date_en = Date_en
let () =
  match Catala_runtime.check_module "MonthYear_en" "CMX|XXXXXXXX|XXXXXXXX|XXXXXXXX"
    with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module MonthYear_en, it may need recompiling"
module MonthYear_en = MonthYear_en
let () =
  match Catala_runtime.check_module "Period_en" "CMX|XXXXXXXX|XXXXXXXX|XXXXXXXX"
    with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module Period_en, it may need recompiling"
module Period_en = Period_en
let () =
  match Catala_runtime.check_module "Money_en" "CMX|XXXXXXXX|XXXXXXXX|XXXXXXXX"
    with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module Money_en, it may need recompiling"
module Money_en = Money_en
let () =
  match Catala_runtime.check_module "Integer_en" "CMX|XXXXXXXX|XXXXXXXX|XXXXXXXX"
    with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module Integer_en, it may need recompiling"
module Integer_en = Integer_en
let () =
  match Catala_runtime.check_module "Decimal_en" "CMX|XXXXXXXX|XXXXXXXX|XXXXXXXX"
    with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module Decimal_en, it may need recompiling"
module Decimal_en = Decimal_en
let () =
  match Catala_runtime.check_module "List_en" "CMX|XXXXXXXX|XXXXXXXX|XXXXXXXX"
    with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module List_en, it may need recompiling"
module List_en = List_en

module Assert_in__1 = struct
  type t = {assert__1: integer}
end

module Assert__1 = struct
  type t = {assert__1: integer}
end

module Assert = struct
  type t = {assert__1: bool}
end

module Assert_in = struct
  type t = unit
end


(* Toplevel def closure_assert *)
let closure_assert : Obj.t(*closure env*) -> integer -> integer =
  fun (env: Obj.t(*closure env*)) (x: integer) ->
    (let _ : unit = (o_fromclosureenv env) in
    ((o_add_int_int x (integer_of_string "1"))))

(* Scope Assert *)
let assert__1 : Assert_in.t -> Assert.t = fun _ ->
  let assert__2: bool =
    match
      (match
         (Optional.Present
            ((let _ : integer array =
                (o_map
                   (let assert__3 :
                      Obj.t(*closure env*) -> integer -> integer =
                      closure_assert in (assert__3, (o_toclosureenv ())))
                   ([|(integer_of_string "0")|])) in false),
              ({filename="tests/name_resolution/good/conflicts.catala_en";
                start_line=23; start_column=3; end_line=23; end_column=59;
                law_headings=[]})))
       with
       | Optional.Absent ->
           (Optional.Present
              (false,
                ({filename="tests/name_resolution/good/conflicts.catala_en";
                  start_line=19; start_column=10; end_line=19; end_column=16;
                  law_headings=[]})))
       | Optional.Present x -> (Optional.Present x))
    with
    | Optional.Absent -> (raise
        (Error (NoValue, [{filename="tests/name_resolution/good/conflicts.catala_en";
                           start_line=19; start_column=10;
                           end_line=19; end_column=16; law_headings=[]}], None)))
    | Optional.Present arg -> (let x, _ = arg in x) in
  {Assert.assert__1 = assert__2}

(* Toplevel def assert *)
let _ : integer -> integer =
  fun (assert__2: integer) -> assert__2

(* Toplevel def closure_assert *)
let _ : (Assert_in__1.t * Assert__1.t) =
  (({Assert_in__1.assert__1 = (integer_of_string "99")}),
    ({Assert__1.assert__1 = (integer_of_string "199")}))
```

```catala-test-cli
$ catala test-scope Assert
┌─[RESULT]─ Assert ─
│ assert = false
└─
```
