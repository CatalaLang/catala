> Module Conflicts-module

```catala-metadata
declaration scope Closure_scøppe:
  output scoppe condition

declaration scope Closure_scoppe1:
  output scoppe condition
```

```catala-test-inline
$ catala ocaml --closure-conversion -O
(** This file has been generated by the Catala compiler, do not edit! *)

open Runtime_ocaml.Runtime

[@@@ocaml.warning "-4-26-27-32-41-42"]


module Closure_scoppe = struct
  type t = {scoppe: bool}
end

module Closure_scoppe1 = struct
  type t = {scoppe: bool}
end

module Closure_scoppe_in = struct
  type t = unit
end

module Closure_scoppe1_in = struct
  type t = unit
end


let closure_scoppe (closure_scoppe_in: Closure_scoppe_in.t) : Closure_scoppe.t =
  let scoppe: bool = false in
  {Closure_scoppe.scoppe = scoppe}

let closure_scoppe1 (closure_scoppe1_in: Closure_scoppe1_in.t) : Closure_scoppe1.t =
  let scoppe: bool = false in
  {Closure_scoppe1.scoppe = scoppe}

let () =
  Runtime_ocaml.Runtime.register_module "Conflicts-module"
    [ "Closure_scoppe1", Obj.repr closure_scoppe1;
      "Closure_sc\195\184ppe", Obj.repr closure_scoppe ]
    "CMX|XXXXXXXX|XXXXXXXX|XXXXXXXX"
```


```catala
scope Closure_scøppe:
  rule scoppe under condition for all x among [ 5; 6; 7 ] we have x > 2
  consequence fulfilled
```

Here we crafted the rule so that a closure will be lifted with a name that
clashes with the scope names ; but such clashes could also happen from other
definitions of private scopes or toplevel definitions.

The addition of this rule should *not* lead to a change in the names of the
symbols that will be exported: the final `register_module` should be the same
below and above (otherwise, users of the module would end up calling the wrong
function!)


```catala-test-inline
$ catala ocaml --closure-conversion -O
(** This file has been generated by the Catala compiler, do not edit! *)

open Runtime_ocaml.Runtime

[@@@ocaml.warning "-4-26-27-32-41-42"]


module Closure_scoppe = struct
  type t = {scoppe: bool}
end

module Closure_scoppe1 = struct
  type t = {scoppe: bool}
end

module Closure_scoppe_in = struct
  type t = unit
end

module Closure_scoppe1_in = struct
  type t = unit
end


let closure_scoppe : Obj.t -> bool -> integer -> bool =
  fun (env: Obj.t) (acc: bool) (x: integer) ->
    o_and acc (o_gt_int_int x (integer_of_string "2"))

let closure_scoppe1 (closure_scoppe_in: Closure_scoppe_in.t) : Closure_scoppe.t =
  let scoppe: bool =
    o_fold (closure_scoppe, (o_toclosureenv ())) true
      ([|(integer_of_string "5"); (integer_of_string "6"); (integer_of_string
         "7")|]) in
  {Closure_scoppe.scoppe = scoppe}

let closure_scoppe2 (closure_scoppe1_in: Closure_scoppe1_in.t) : Closure_scoppe1.t =
  let scoppe: bool = false in
  {Closure_scoppe1.scoppe = scoppe}

let () =
  Runtime_ocaml.Runtime.register_module "Conflicts-module"
    [ "Closure_scoppe1", Obj.repr closure_scoppe2;
      "Closure_sc\195\184ppe", Obj.repr closure_scoppe1;
      "closure_scoppe", Obj.repr closure_scoppe ]
    "CMX|XXXXXXXX|XXXXXXXX|XXXXXXXX"
```
