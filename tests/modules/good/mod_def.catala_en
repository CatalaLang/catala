# Test modules + inclusions 1

> Module Mod_def

```catala-metadata
declaration enumeration Mod_def:
  -- Yes
  -- No
  -- Maybe

declaration structure Str1:
  data fld1 content Mod_def
  data fld2 content integer

#[test] declaration scope S:
  output sr content money
  output e1 content Mod_def

declaration half content decimal
  depends on x content integer
  equals x / Date.get_year of |0002-01-01|

declaration maybe content Mod_def
  depends on x content Mod_def
```

```catala
scope S:
  definition sr equals $1,000
  definition e1 equals Maybe


declaration maybe content Mod_def
  depends on x content Mod_def
  equals Maybe
```



```catala-test-cli
$ catala Typecheck --check-invariants
┌─[RESULT]─
│ All invariant checks passed
└─
┌─[RESULT]─
│ Typechecking successful!
└─
```

```catala-test-cli
$ catala typecheck --disable-warnings
┌─[RESULT]─
│ Typechecking successful!
└─
```

```catala-test-cli
$ catala ocaml --disable-warnings
(** This file has been generated by the Catala compiler, do not edit! *)

[@@@ocaml.warning "-4-26-27-32-33-34-37-41-42-69"]

open Catala_runtime


let () =
  match Catala_runtime.check_module "Stdlib_en" "CMX|XXXXXXXX|XXXXXXXX|XXXXXXXX"
    with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module Stdlib_en, it may need recompiling"
module Stdlib_en = Stdlib_en
let () =
  match Catala_runtime.check_module "Date_en" "CMX|XXXXXXXX|XXXXXXXX|XXXXXXXX"
    with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module Date_en, it may need recompiling"
module Date_en = Date_en
let () =
  match Catala_runtime.check_module "Duration_en" "CMX|XXXXXXXX|XXXXXXXX|XXXXXXXX"
    with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module Duration_en, it may need recompiling"
module Duration_en = Duration_en
let () =
  match Catala_runtime.check_module "MonthYear_en" "CMX|XXXXXXXX|XXXXXXXX|XXXXXXXX"
    with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module MonthYear_en, it may need recompiling"
module MonthYear_en = MonthYear_en
let () =
  match Catala_runtime.check_module "Period_en" "CMX|XXXXXXXX|XXXXXXXX|XXXXXXXX"
    with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module Period_en, it may need recompiling"
module Period_en = Period_en
let () =
  match Catala_runtime.check_module "Money_en" "CMX|XXXXXXXX|XXXXXXXX|XXXXXXXX"
    with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module Money_en, it may need recompiling"
module Money_en = Money_en
let () =
  match Catala_runtime.check_module "Integer_en" "CMX|XXXXXXXX|XXXXXXXX|XXXXXXXX"
    with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module Integer_en, it may need recompiling"
module Integer_en = Integer_en
let () =
  match Catala_runtime.check_module "Decimal_en" "CMX|XXXXXXXX|XXXXXXXX|XXXXXXXX"
    with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module Decimal_en, it may need recompiling"
module Decimal_en = Decimal_en
let () =
  match Catala_runtime.check_module "List_en" "CMX|XXXXXXXX|XXXXXXXX|XXXXXXXX"
    with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module List_en, it may need recompiling"
module List_en = List_en

module Mod_def = struct type t = Yes | No | Maybe end

module S = struct
  type t = {sr: money; e1: Mod_def.t}
end

module Str1 = struct
  type t = {fld1: Mod_def.t; fld2: integer}
end

module S_in = struct
  type t = unit
end


(* Scope S *)
let s : S_in.t -> S.t = fun _ ->
  let sr: money =
    match
      (Optional.Present
         ((money_of_cents_string "100000"),
           ({filename="tests/modules/good/mod_def.catala_en";
             start_line=29; start_column=24; end_line=29; end_column=30;
             law_headings=["Test modules + inclusions 1"]})))
    with
    | Optional.Absent -> (raise
        (Error (NoValue, [{filename="tests/modules/good/mod_def.catala_en";
                           start_line=16; start_column=10;
                           end_line=16; end_column=12;
                           law_headings=["Test modules + inclusions 1"]}], None)))
    | Optional.Present arg -> (let x, _ = arg in x) in
  let e1: Mod_def.t =
    match
      (Optional.Present
         ((Mod_def.Maybe),
           ({filename="tests/modules/good/mod_def.catala_en";
             start_line=30; start_column=24; end_line=30; end_column=29;
             law_headings=["Test modules + inclusions 1"]})))
    with
    | Optional.Absent -> (raise
        (Error (NoValue, [{filename="tests/modules/good/mod_def.catala_en";
                           start_line=17; start_column=10;
                           end_line=17; end_column=12;
                           law_headings=["Test modules + inclusions 1"]}], None)))
    | Optional.Present arg -> (let x, _ = arg in x) in
  {S.sr = sr; S.e1 = e1}

(* Toplevel def half *)
let half : integer -> decimal =
  fun (x: integer) ->
    o_div_int_int
      {filename="tests/modules/good/mod_def.catala_en";
       start_line=21; start_column=14; end_line=21; end_column=43;
       law_headings=["Test modules + inclusions 1"]} x
      ((Date_en.get_year) (date_of_numbers (2) (1) (1)))

(* Toplevel def maybe *)
let maybe : Mod_def.t -> Mod_def.t =
  fun (_: Mod_def.t) -> Mod_def.Maybe

let () =
  Catala_runtime.register_module "Mod_def"
    [ "S", Stdlib.Obj.repr s;
      "half", Stdlib.Obj.repr half;
      "maybe", Stdlib.Obj.repr maybe ]
    "CMX|XXXXXXXX|XXXXXXXX|XXXXXXXX"
```
