Testing adequacy of the scope calling convention with various types of
parameters (reentrant, functions ...) ; and different calls (through subscopes
or direct scope calls). The main part of the test is in `mod_use_context`.

> Module Mod_def_context

```catala-metadata
declaration scope S:
  context output ci content integer
  context output cm content money
  context output cfun1 content decimal depends on x content integer
  input output cfun2 content decimal depends on x content integer
```

```catala
scope S:
  definition ci equals 0
  definition cm equals $0
  definition cfun1 of x equals x / 2
```

Now testing direct calls within the same module

```catala-metadata
declaration third content decimal
  depends on x content integer
  equals x / 3

declaration quarter content decimal
  depends on x content integer
  equals x / 4
```

```catala
declaration scope Stest:
  output o1 content S
  output o2 content S
  output x11 content decimal
  output x12 content decimal
  output x21 content decimal
  output x22 content decimal

scope Stest:
  definition o1 equals
      output of S with { -- cfun2: quarter }
  definition o2 equals
      output of S with {
        -- ci: 1
        -- cm: $1
        -- cfun1: third
        -- cfun2: quarter
      }
  definition x11 equals o1.cfun1 of 24
  definition x12 equals o1.cfun2 of 24
  definition x21 equals o2.cfun1 of 24
  definition x22 equals o2.cfun2 of 24
```



```catala-test-inline
$ catala Typecheck --check_invariants
[RESULT]
Invariant Dcalc__Invariants.invariant_typing_defaults
   checked. result: [210/210]
[RESULT]
Invariant Dcalc__Invariants.invariant_match_inversion
   checked. result: [0/0]
[RESULT]
Invariant Dcalc__Invariants.invariant_app_inversion
   checked. result: [21/21]
[RESULT]
Invariant Dcalc__Invariants.invariant_no_return_a_function
   checked. result: [17/17]
[RESULT]
Invariant Dcalc__Invariants.invariant_no_partial_evaluation
   checked. result: [21/21]
[RESULT]
Invariant Dcalc__Invariants.invariant_default_no_arrow
   checked. result: [22/22]
[RESULT] Typechecking successful!
```

```catala-test-inline
$ catala interpret -s Stest
[RESULT] Computation successful! Results:
[RESULT]
o1 = S { -- ci: 0 -- cm: $0.00 -- cfun1: <function> -- cfun2: <function> }
[RESULT]
o2 = S { -- ci: 1 -- cm: $1.00 -- cfun1: <function> -- cfun2: <function> }
[RESULT] x11 = 12.0
[RESULT] x12 = 6.0
[RESULT] x21 = 8.0
[RESULT] x22 = 6.0
```

### Testing subscopes (with and without context override)

```catala
declaration scope TestSubDefault:
  sub scope S
  output ci content integer
  output cm content money
  output x11 content decimal
  output x12 content decimal

scope TestSubDefault:
  definition sub.cfun2 of x equals quarter of x
  definition ci equals sub.ci
  definition cm equals sub.cm
  definition x11 equals sub.cfun1 of 24
  definition x12 equals sub.cfun2 of 24
```

```catala-test-inline
$ catala interpret -s TestSubDefault
[RESULT] Computation successful! Results:
[RESULT] ci = 0
[RESULT] cm = $0.00
[RESULT] x11 = 12.0
[RESULT] x12 = 6.0
```

```catala
declaration scope TestSubOverride:
  sub scope S
  output ci content integer
  output cm content money
  output x21 content decimal
  output x22 content decimal

scope TestSubOverride:
  definition sub.ci equals 1
  definition sub.cm equals $1
  definition sub.cfun1 of x equals third of x
  definition sub.cfun2 of x equals quarter of x
  definition ci equals sub.ci
  definition cm equals sub.cm
  definition x21 equals sub.cfun1 of 24
  definition x22 equals sub.cfun2 of 24
```

```catala-test-inline
$ catala interpret -s TestSubOverride
[RESULT] Computation successful! Results:
[RESULT] ci = 1
[RESULT] cm = $1.00
[RESULT] x21 = 8.0
[RESULT] x22 = 6.0
```
