```catala
declaration scope HousingComputation:
  output f content integer depends on x content integer
  output result content integer

scope HousingComputation:
  definition f of x equals (output of RentComputation).f of x
  definition result equals f of 1

declaration scope RentComputation:
  internal g content integer depends on x content integer
  output f content integer depends on x content integer

scope RentComputation:
  definition g of x equals x + 1
  definition f of x equals g of (x + 1)
```



```catala-test-inline
$ catala Typecheck --check-invariants
[RESULT]
Invariant Dcalc__Invariants.invariant_typing_defaults
   checked. result: [69/69]
[RESULT]
Invariant Dcalc__Invariants.invariant_match_inversion
   checked. result: [0/0]
[RESULT]
Invariant Dcalc__Invariants.invariant_app_inversion
   checked. result: [9/9]
[RESULT]
Invariant Dcalc__Invariants.invariant_no_return_a_function
   checked. result: [6/6]
[RESULT]
Invariant Dcalc__Invariants.invariant_no_partial_evaluation
   checked. result: [9/9]
[RESULT]
Invariant Dcalc__Invariants.invariant_default_no_arrow
   checked. result: [8/8]
[RESULT] Typechecking successful!
```

```catala-test-inline
$ catala Interpret -t -s HousingComputation --debug
[DEBUG] = INIT =
[DEBUG] = SURFACE =
[DEBUG] Parsing "tests/test_scope/good/scope_call3.catala_en"
[DEBUG] = DESUGARED =
[DEBUG] Name resolution...
[DEBUG] Desugaring...
[DEBUG] Disambiguating...
[DEBUG] Linting...
[DEBUG] = SCOPELANG =
[DEBUG] = DCALC =
[DEBUG] Typechecking...
[DEBUG] Translating to default calculus...
[DEBUG] Typechecking again...
[DEBUG] Starting interpretation...
[LOG] ≔  HousingComputation.f: λ (x_76: integer) → error_empty ⟨ ⟨#{☛ } true ⊢ ⟨(let result_77 : RentComputation = (#{→ RentComputation.direct} (λ (RentComputation_in_78: RentComputation_in) → let g_79 : integer → integer = #{≔ RentComputation.g} (λ (x1_80: integer) → error_empty ⟨ ⟨#{☛ } true ⊢ ⟨x1_80 +! 1⟩⟩ | false ⊢ ∅ ⟩) in let f_81 : integer → integer = #{≔ RentComputation.f} (λ (x1_82: integer) → error_empty ⟨ ⟨#{☛ } true ⊢ ⟨#{← RentComputation.g} #{≔ RentComputation.g.output} (#{→ RentComputation.g} g_79) #{≔ RentComputation.g.input0} (x1_82 +! 1)⟩⟩ | false ⊢ ∅ ⟩) in { RentComputation f = f_81; })) #{≔ RentComputation.direct.input} {RentComputation_in} in let result1_83 : RentComputation = { RentComputation f = λ (param0_84: integer) → #{← RentComputation.f} #{≔ RentComputation.f.output} (#{→ RentComputation.f} result_77.f) #{≔ RentComputation.f.input0} param0_84; } in #{← RentComputation.direct} #{≔ RentComputation.direct.output} if #{☛ RentComputation.direct.output} true then result1_83 else result1_83).f x_76⟩⟩ | false ⊢ ∅ ⟩
[LOG] ☛ Definition applied:
      ┌─⯈ tests/test_scope/good/scope_call3.catala_en:8.14-8.20:
      └─┐
      8 │   definition result equals f of 1
        │              ‾‾‾‾‾‾
[LOG] →  HousingComputation.f
[LOG]   ≔  HousingComputation.f.input0: 1
[LOG]   ☛ Definition applied:
        ┌─⯈ tests/test_scope/good/scope_call3.catala_en:7.14-7.15:
        └─┐
        7 │   definition f of x equals (output of RentComputation).f of x
          │              ‾
[LOG]   →  RentComputation.direct
[LOG]     ≔  RentComputation.direct.input: {RentComputation_in}
[LOG]     ≔  RentComputation.g: λ (x_85: integer) → error_empty ⟨ ⟨#{☛ } true ⊢ ⟨x_85 +! 1⟩⟩ | false ⊢ ∅ ⟩
[LOG]     ≔  RentComputation.f: λ (x_86: integer) → error_empty ⟨ ⟨#{☛ } true ⊢ ⟨#{← RentComputation.g} #{≔ RentComputation.g.output} (#{→ RentComputation.g} (λ (x1_87: integer) → error_empty ⟨ ⟨#{☛ } true ⊢ ⟨x1_87 +! 1⟩⟩ | false ⊢ ∅ ⟩)) #{≔ RentComputation.g.input0} (x_86 +! 1)⟩⟩ | false ⊢ ∅ ⟩
[LOG]     ☛ Definition applied:
          ┌─⯈ tests/test_scope/good/scope_call3.catala_en:7.29-7.54:
          └─┐
          7 │   definition f of x equals (output of RentComputation).f of x
            │                             ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
[LOG]     ≔  RentComputation.direct.output: { RentComputation f = λ (param0_88: integer) → #{← RentComputation.f} #{≔ RentComputation.f.output} (#{→ RentComputation.f} { RentComputation f = λ (x_89: integer) → error_empty ⟨ ⟨#{☛ } true ⊢ ⟨#{← RentComputation.g} #{≔ RentComputation.g.output} (#{→ RentComputation.g} (λ (x1_90: integer) → error_empty ⟨ ⟨#{☛ } true ⊢ ⟨x1_90 +! 1⟩⟩ | false ⊢ ∅ ⟩)) #{≔ RentComputation.g.input0} (x_89 +! 1)⟩⟩ | false ⊢ ∅ ⟩; }.f) #{≔ RentComputation.f.input0} param0_88; }
[LOG]   ←  RentComputation.direct
[LOG]   →  RentComputation.f
[LOG]     ≔  RentComputation.f.input0: 1
[LOG]     ☛ Definition applied:
          ┌─⯈ tests/test_scope/good/scope_call3.catala_en:16.14-16.15:
          └──┐
          16 │   definition f of x equals g of (x + 1)
             │              ‾
[LOG]     →  RentComputation.g
[LOG]       ≔  RentComputation.g.input0: 2
[LOG]       ☛ Definition applied:
            ┌─⯈ tests/test_scope/good/scope_call3.catala_en:15.14-15.15:
            └──┐
            15 │   definition g of x equals x + 1
               │              ‾
[LOG]       ≔  RentComputation.g.output: 3
[LOG]     ←  RentComputation.g
[LOG]     ≔  RentComputation.f.output: 3
[LOG]   ←  RentComputation.f
[LOG]   ≔  HousingComputation.f.output: 3
[LOG] ←  HousingComputation.f
[LOG] ≔  HousingComputation.result: 3
[DEBUG] End of interpretation
[RESULT] Computation successful! Results:
[RESULT]
f = λ (x: integer) →
  error_empty
    ⟨ ⟨true
       ⊢ ⟨(let result : RentComputation =
             (λ (RentComputation_in: RentComputation_in) →
              let g : integer → integer =
                λ (x1: integer) →
                error_empty ⟨ ⟨true ⊢ ⟨x1 + 1⟩⟩ | false ⊢ ∅ ⟩
              in
              let f : integer → integer =
                λ (x1: integer) →
                error_empty ⟨ ⟨true ⊢ ⟨g (x1 + 1)⟩⟩ | false ⊢ ∅ ⟩
              in
              { RentComputation f = f; })
               {RentComputation_in}
           in
           let result1 : RentComputation =
             { RentComputation f = λ (param0: integer) → result.f param0; }
           in
           if true then result1 else result1).
            f
            x⟩⟩
    | false ⊢ ∅ ⟩
[RESULT] result = 3
```
