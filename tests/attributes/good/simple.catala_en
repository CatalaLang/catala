# Some simple attribute tests

## First tests

```catala
#[attr = "Referring to the scope declaration"]
declaration scope S:
  context output bla content integer #
  output x content money
  #[attr.unit]
  #[a]
  output o content money
  #[attr.expr = false]
  #[attr.multi = "string"]
  output o2 content (money, #[attr.typ] integer)

#[struct.attribute]
declaration scope S2:
  output x content integer

declaration structure Str:
  #[field.lbl = "psst"]
  data fld content #[typ] integer
  data fld2 content #[
attributes.can
=
"be multi- \
          \  \"line\"
as well"
] (integer, date)

#[enum00]
#[this.is_an = Enum]
declaration enumeration Enu:
  -- Foo
  #[constructor = "Bar"]
  -- Bar

```

```catala-test-inline
$ catala scopelang --disable-warnings
#[enum00]
#[this.is_an = <expr>]
type Enu =
  | Foo of unit
  | #[constructor = "Bar"] Bar of unit

#[attr = "Referring to the scope declaration"]
type S = {
  bla: integer;
  x: money;
  #[a] #[attr.unit] o: money;
  #[attr.multi = "string"] #[attr.expr = <expr>]
  o2: (money, #[attr.typ] integer);
}

#[struct.attribute]
type S2 = { x: integer; }

type Str = {
  #[field.lbl = "psst"] fld: #[typ] integer;
  fld2: #[attributes.can = "be multi-   \"line\"\nas well"] (integer, date);
}


#[attr = "Referring to the scope declaration"]
let scope S
    (bla: ⟨integer⟩|context|output)
    (x: money|internal|output)
    (o: money|internal|output)
    (o2: (money, #[attr.typ] integer)|internal|output)
  =
  let bla : integer = reentrant or by default error_empty ⟨false ⊢ ∅⟩;
  let x : money = error_empty ⟨false ⊢ ∅⟩;
  #[a]
  #[attr.unit]
  let o : money = error_empty ⟨false ⊢ ∅⟩;
  #[attr.multi = "string"]
  #[attr.expr = <expr>]
  let o2 : (money, #[attr.typ] integer) = error_empty ⟨false ⊢ ∅⟩

#[struct.attribute]
let scope S2 (x: integer|internal|output) =
  let x : integer = error_empty ⟨false ⊢ ∅⟩
```
