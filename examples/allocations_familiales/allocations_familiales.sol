// This file has been generated by the Catala compiler, do not edit!

pragma solidity ^0.8.19;
     
type Unit is bool;

struct Duration { int256 value; }
function eq(Duration calldata a, Duration calldata b) pure returns (bool) { return(a.value == b.value); }
function ne(Duration calldata a, Duration calldata b) pure returns (bool) { return(!eq(a, b)); }

struct Money { Integer value; }
function eq(Money calldata a, Money calldata b) pure returns (bool) { return(eq(a.value, b.value)); }
function ne(Money calldata a, Money calldata b) pure returns (bool) { return(!eq(a, b)); }

struct Integer { int256 value; }
function eq(Integer calldata a, Integer calldata b) pure returns (bool) { return(a.value == b.value); }
function ne(Integer calldata a, Integer calldata b) pure returns (bool) { return(!eq(a, b)); }

struct Decimal { fixed256x80 value; }
function eq(Decimal calldata a, Decimal calldata b) pure returns (bool) { return(a.value == b.value); }
function ne(Decimal calldata a, Decimal calldata b) pure returns (bool) { return(!eq(a, b)); }

struct Date { int64 value; }
function eq(Date calldata a, Date calldata b) pure returns (bool) { return(a.value == b.value); }
function ne(Date calldata a, Date calldata b) pure returns (bool) { return(!eq(a, b)); }

enum PriseEnCharge {
    GardeAlterneePartageAllocations,
    GardeAlterneeAllocataireUnique,
    EffectiveEtPermanente,
    ServicesSociauxAllocationVerseeALaFamille,
    ServicesSociauxAllocationVerseeAuxServicesSociaux
}

enum SituationObligationScolaire {
    Avant,
    Pendant,
    Apres
}

enum PriseEnCompte {
    Complete,
    Partagee,
    Zero
}

enum VersementAllocations {
    Normal,
    AllocationVerseeAuxServicesSociaux
}

enum ElementPrestationsFamiliales {
    PrestationAccueilJeuneEnfant,
    AllocationsFamiliales,
    ComplementFamilial,
    AllocationLogement,
    AllocationEducationEnfantHandicape,
    AllocationSoutienFamilial,
    AllocationRentreeScolaire,
    AllocationJournalierePresenceParentale
}

enum Collectivite {
    Guadeloupe,
    Guyane,
    Martinique,
    LaReunion,
    SaintBarthelemy,
    SaintMartin,
    Metropole,
    SaintPierreEtMiquelon,
    Mayotte
}

struct AllocationFamilialesAvril2008 {
    Duration age_minimum_alinea_1_l521_3;
}

function eq(AllocationFamilialesAvril2008 calldata a, AllocationFamilialesAvril2008 calldata b)
    pure
    returns (bool)
{
    return(
        eq(a.age_minimum_alinea_1_l521_3, b.age_minimum_alinea_1_l521_3)
    );
}

function eq(AllocationFamilialesAvril2008[] calldata a, AllocationFamilialesAvril2008[] calldata b)
    pure
    returns (bool)
{
    if (a.length != b.length) return false;
    for (uint i = 0; i < a.length; i++) {
        if (!eq(a[i], b[i])) {
            return false;
        }
    }
    return true;
}

struct AllocationsFamiliales {
    Money montant_verse;
}

function eq(AllocationsFamiliales calldata a, AllocationsFamiliales calldata b)
    pure
    returns (bool)
{
    return(
        eq(a.montant_verse, b.montant_verse)
    );
}

function eq(AllocationsFamiliales[] calldata a, AllocationsFamiliales[] calldata b)
    pure
    returns (bool)
{
    if (a.length != b.length) return false;
    for (uint i = 0; i < a.length; i++) {
        if (!eq(a[i], b[i])) {
            return false;
        }
    }
    return true;
}

struct Smic {
    Money brut_horaire;
}

function eq(Smic calldata a, Smic calldata b)
    pure
    returns (bool)
{
    return(
        eq(a.brut_horaire, b.brut_horaire)
    );
}

function eq(Smic[] calldata a, Smic[] calldata b)
    pure
    returns (bool)
{
    if (a.length != b.length) return false;
    for (uint i = 0; i < a.length; i++) {
        if (!eq(a[i], b[i])) {
            return false;
        }
    }
    return true;
}

struct BaseMensuelleAllocationsFamiliales {
    Money montant;
}

function eq(BaseMensuelleAllocationsFamiliales calldata a, BaseMensuelleAllocationsFamiliales calldata b)
    pure
    returns (bool)
{
    return(
        eq(a.montant, b.montant)
    );
}

function eq(BaseMensuelleAllocationsFamiliales[] calldata a, BaseMensuelleAllocationsFamiliales[] calldata b)
    pure
    returns (bool)
{
    if (a.length != b.length) return false;
    for (uint i = 0; i < a.length; i++) {
        if (!eq(a[i], b[i])) {
            return false;
        }
    }
    return true;
}

struct InterfaceAllocationsFamiliales {
    Money i_montant_verse;
}

function eq(InterfaceAllocationsFamiliales calldata a, InterfaceAllocationsFamiliales calldata b)
    pure
    returns (bool)
{
    return(
        eq(a.i_montant_verse, b.i_montant_verse)
    );
}

function eq(InterfaceAllocationsFamiliales[] calldata a, InterfaceAllocationsFamiliales[] calldata b)
    pure
    returns (bool)
{
    if (a.length != b.length) return false;
    for (uint i = 0; i < a.length; i++) {
        if (!eq(a[i], b[i])) {
            return false;
        }
    }
    return true;
}

struct EnfantEntree {
    Integer d_identifiant;
    Money d_remuneration_mensuelle;
    Date d_date_de_naissance;
    PriseEnCharge d_prise_en_charge;
    bool d_a_deja_ouvert_droit_aux_allocations_familiales;
    bool d_beneficie_titre_personnel_aide_personnelle_logement;
}

function eq(EnfantEntree calldata a, EnfantEntree calldata b)
    pure
    returns (bool)
{
    return(
        eq(a.d_identifiant, b.d_identifiant) && 
        eq(a.d_remuneration_mensuelle, b.d_remuneration_mensuelle) && 
        eq(a.d_date_de_naissance, b.d_date_de_naissance) && 
        (a.d_prise_en_charge == b.d_prise_en_charge) && 
        (a.d_a_deja_ouvert_droit_aux_allocations_familiales == b.d_a_deja_ouvert_droit_aux_allocations_familiales) && 
        (a.d_beneficie_titre_personnel_aide_personnelle_logement == b.d_beneficie_titre_personnel_aide_personnelle_logement)
    );
}

function eq(EnfantEntree[] calldata a, EnfantEntree[] calldata b)
    pure
    returns (bool)
{
    if (a.length != b.length) return false;
    for (uint i = 0; i < a.length; i++) {
        if (!eq(a[i], b[i])) {
            return false;
        }
    }
    return true;
}

struct Enfant {
    Integer identifiant;
    SituationObligationScolaire obligation_scolaire;
    Money remuneration_mensuelle;
    Date date_de_naissance;
    PriseEnCharge prise_en_charge;
    bool a_deja_ouvert_droit_aux_allocations_familiales;
    bool beneficie_titre_personnel_aide_personnelle_logement;
}

function eq(Enfant calldata a, Enfant calldata b)
    pure
    returns (bool)
{
    return(
        eq(a.identifiant, b.identifiant) && 
        (a.obligation_scolaire == b.obligation_scolaire) && 
        eq(a.remuneration_mensuelle, b.remuneration_mensuelle) && 
        eq(a.date_de_naissance, b.date_de_naissance) && 
        (a.prise_en_charge == b.prise_en_charge) && 
        (a.a_deja_ouvert_droit_aux_allocations_familiales == b.a_deja_ouvert_droit_aux_allocations_familiales) && 
        (a.beneficie_titre_personnel_aide_personnelle_logement == b.beneficie_titre_personnel_aide_personnelle_logement)
    );
}

function eq(Enfant[] calldata a, Enfant[] calldata b)
    pure
    returns (bool)
{
    if (a.length != b.length) return false;
    for (uint i = 0; i < a.length; i++) {
        if (!eq(a[i], b[i])) {
            return false;
        }
    }
    return true;
}

struct EnfantLePlusAge {
    Enfant le_plus_age;
}

function eq(EnfantLePlusAge calldata a, EnfantLePlusAge calldata b)
    pure
    returns (bool)
{
    return(
        eq(a.le_plus_age, b.le_plus_age)
    );
}

function eq(EnfantLePlusAge[] calldata a, EnfantLePlusAge[] calldata b)
    pure
    returns (bool)
{
    if (a.length != b.length) return false;
    for (uint i = 0; i < a.length; i++) {
        if (!eq(a[i], b[i])) {
            return false;
        }
    }
    return true;
}

struct PrestationsFamiliales {
    function (Enfant calldata) returns (bool) droit_ouvert;
    function (Enfant calldata) returns (bool) conditions_hors_age;
    Duration age_l512_3_2;
    bool regime_outre_mer_l751_1;
}

function eq(PrestationsFamiliales calldata a, PrestationsFamiliales calldata b)
    pure
    returns (bool)
{
    return(
        (a.droit_ouvert == b.droit_ouvert) && 
        (a.conditions_hors_age == b.conditions_hors_age) && 
        eq(a.age_l512_3_2, b.age_l512_3_2) && 
        (a.regime_outre_mer_l751_1 == b.regime_outre_mer_l751_1)
    );
}

function eq(PrestationsFamiliales[] calldata a, PrestationsFamiliales[] calldata b)
    pure
    returns (bool)
{
    if (a.length != b.length) return false;
    for (uint i = 0; i < a.length; i++) {
        if (!eq(a[i], b[i])) {
            return false;
        }
    }
    return true;
}

struct PrestationsFamilialesIn {
    Date date_courante_in;
    ElementPrestationsFamiliales prestation_courante_in;
    Collectivite residence_in;
}

function eq(PrestationsFamilialesIn calldata a, PrestationsFamilialesIn calldata b)
    pure
    returns (bool)
{
    return(
        eq(a.date_courante_in, b.date_courante_in) && 
        (a.prestation_courante_in == b.prestation_courante_in) && 
        (a.residence_in == b.residence_in)
    );
}

function eq(PrestationsFamilialesIn[] calldata a, PrestationsFamilialesIn[] calldata b)
    pure
    returns (bool)
{
    if (a.length != b.length) return false;
    for (uint i = 0; i < a.length; i++) {
        if (!eq(a[i], b[i])) {
            return false;
        }
    }
    return true;
}

type AllocationFamilialesAvril2008In is bool;

struct EnfantLePlusAgeIn {
    Enfant[] enfants_in;
}

function eq(EnfantLePlusAgeIn calldata a, EnfantLePlusAgeIn calldata b)
    pure
    returns (bool)
{
    return(
        eq(a.enfants_in, b.enfants_in)
    );
}

function eq(EnfantLePlusAgeIn[] calldata a, EnfantLePlusAgeIn[] calldata b)
    pure
    returns (bool)
{
    if (a.length != b.length) return false;
    for (uint i = 0; i < a.length; i++) {
        if (!eq(a[i], b[i])) {
            return false;
        }
    }
    return true;
}

struct AllocationsFamilialesIn {
    bool personne_charge_effective_permanente_est_parent_in;
    bool personne_charge_effective_permanente_remplit_titre_I_in;
    Money ressources_menage_in;
    Collectivite residence_in;
    Date date_courante_in;
    Enfant[] enfants_a_charge_in;
    bool avait_enfant_a_charge_avant_1er_janvier_2012_in;
}

function eq(AllocationsFamilialesIn calldata a, AllocationsFamilialesIn calldata b)
    pure
    returns (bool)
{
    return(
        (a.personne_charge_effective_permanente_est_parent_in == b.personne_charge_effective_permanente_est_parent_in) && 
        (a.personne_charge_effective_permanente_remplit_titre_I_in == b.personne_charge_effective_permanente_remplit_titre_I_in) && 
        eq(a.ressources_menage_in, b.ressources_menage_in) && 
        (a.residence_in == b.residence_in) && 
        eq(a.date_courante_in, b.date_courante_in) && 
        eq(a.enfants_a_charge_in, b.enfants_a_charge_in) && 
        (a.avait_enfant_a_charge_avant_1er_janvier_2012_in == b.avait_enfant_a_charge_avant_1er_janvier_2012_in)
    );
}

function eq(AllocationsFamilialesIn[] calldata a, AllocationsFamilialesIn[] calldata b)
    pure
    returns (bool)
{
    if (a.length != b.length) return false;
    for (uint i = 0; i < a.length; i++) {
        if (!eq(a[i], b[i])) {
            return false;
        }
    }
    return true;
}

struct SmicIn {
    Date date_courante_in;
    Collectivite residence_in;
}

function eq(SmicIn calldata a, SmicIn calldata b)
    pure
    returns (bool)
{
    return(
        eq(a.date_courante_in, b.date_courante_in) && 
        (a.residence_in == b.residence_in)
    );
}

function eq(SmicIn[] calldata a, SmicIn[] calldata b)
    pure
    returns (bool)
{
    if (a.length != b.length) return false;
    for (uint i = 0; i < a.length; i++) {
        if (!eq(a[i], b[i])) {
            return false;
        }
    }
    return true;
}

struct BaseMensuelleAllocationsFamilialesIn {
    Date date_courante_in;
}

function eq(BaseMensuelleAllocationsFamilialesIn calldata a, BaseMensuelleAllocationsFamilialesIn calldata b)
    pure
    returns (bool)
{
    return(
        eq(a.date_courante_in, b.date_courante_in)
    );
}

function eq(BaseMensuelleAllocationsFamilialesIn[] calldata a, BaseMensuelleAllocationsFamilialesIn[] calldata b)
    pure
    returns (bool)
{
    if (a.length != b.length) return false;
    for (uint i = 0; i < a.length; i++) {
        if (!eq(a[i], b[i])) {
            return false;
        }
    }
    return true;
}

struct InterfaceAllocationsFamilialesIn {
    Date i_date_courante_in;
    EnfantEntree[] i_enfants_in;
    Money i_ressources_menage_in;
    Collectivite i_residence_in;
    bool i_personne_charge_effective_permanente_est_parent_in;
    bool i_personne_charge_effective_permanente_remplit_titre_I_in;
    bool i_avait_enfant_a_charge_avant_1er_janvier_2012_in;
}

function eq(InterfaceAllocationsFamilialesIn calldata a, InterfaceAllocationsFamilialesIn calldata b)
    pure
    returns (bool)
{
    return(
        eq(a.i_date_courante_in, b.i_date_courante_in) && 
        eq(a.i_enfants_in, b.i_enfants_in) && 
        eq(a.i_ressources_menage_in, b.i_ressources_menage_in) && 
        (a.i_residence_in == b.i_residence_in) && 
        (a.i_personne_charge_effective_permanente_est_parent_in == b.i_personne_charge_effective_permanente_est_parent_in) && 
        (a.i_personne_charge_effective_permanente_remplit_titre_I_in == b.i_personne_charge_effective_permanente_remplit_titre_I_in) && 
        (a.i_avait_enfant_a_charge_avant_1er_janvier_2012_in == b.i_avait_enfant_a_charge_avant_1er_janvier_2012_in)
    );
}

function eq(InterfaceAllocationsFamilialesIn[] calldata a, InterfaceAllocationsFamilialesIn[] calldata b)
    pure
    returns (bool)
{
    if (a.length != b.length) return false;
    for (uint i = 0; i < a.length; i++) {
        if (!eq(a[i], b[i])) {
            return false;
        }
    }
    return true;
}

